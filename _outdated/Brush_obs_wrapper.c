/*
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is a wrapper S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_wrapper_XXXXX_Changes_BEGIN 
  *            Your Changes go here
  *        %%%-SFUNWIZ_wrapper_XXXXXX_Changes_END
  *
  *   For better compatibility with the Real-Time Workshop, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Real-Time Workshop User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *   Created: Mon Apr  6 14:11:39 2009
  */


/*
 * Include Files
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif
/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <math.h>
/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */
#define u_width 1
#define y_width 1
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
/* extern double func(double a); */
/* %%%-SFUNWIZ_wrapper_externs_Changes_END --- EDIT HERE TO _BEGIN */

/*
 * Output functions
 *
 */
void Brush_Outputs_wrapper(const real_T *sigma,
                          const real_T *muFz,
                          const real_T *alpha,
                          real_T *Fx,
                          real_T *Fy,
                          real_T *Tsat  , 
                          const real_T  *Ca, const int_T  p_width0, 
                          const real_T  *Cs,  const int_T p_width1,
                          const real_T  *lc,  const int_T p_width2)
{
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_BEGIN --- EDIT HERE TO _END */
/* This sample sets the output equal to the input
         y0[0] = u0[0];
For complex signals use: y0[0].re = u0[0].re;
                         y0[0].im = u0[0].im;
                         y1[0].re = u1[0].re;
                         y1[0].im = u1[0].im;*/
double W ;
double K_sigma ; 
double K_alpha ;
double l ;
double lambda ;
double xi;
double Cos_theta;
double Sin_theta;


W=muFz[0];
K_sigma=Cs[0]; // 45000.0;
K_alpha=Ca[0];
l=lc[0];


if ( sigma[0] >= 0 ){
    lambda = sqrt(sigma[0]*sigma[0]+ pow(K_alpha/K_sigma,2)*tan(alpha[0])*tan(alpha[0]));
    xi = 1.0-K_sigma/(3.0*W)*lambda/(1.0-sigma[0]);

    if (lambda == 0 && sigma[0] == 0){   
        Cos_theta = 1.0;
        Sin_theta = 0.0;
    }
    else {        
        Cos_theta = sigma[0]/lambda;
        Sin_theta = K_alpha*tan(alpha[0])/(K_sigma*lambda);
    }


    if (xi > 0){    
        Fx[0] = -K_sigma*sigma[0]/(1-sigma[0])*pow(xi,2)-6.0*W*Cos_theta*(1.0/6.0-1.0/2.0*xi*xi+1.0/3.0*xi*xi*xi);
        Fy[0] = -K_alpha*tan(alpha[0])/(1-sigma[0])*pow(xi,2)-6.0*W*Sin_theta*(1.0/6.0-1.0/2.0*pow(xi,2)+1.0/3.0*pow(xi,3));
        Tsat[0] = l*K_alpha*tan(alpha[0])/(2.0*(1.0-sigma[0]))*pow(xi,2)*(1.0-4.0/3.0*xi)
         -3.0/2.0*l*W*Sin_theta*pow(xi,2)*pow(1-xi,2)
         +2.0*l*K_sigma*sigma[0]*tan(alpha[0])/(3.0*pow(1.0-sigma[0],2))*pow(xi,3)
         +3.0*l*pow(W,2)*Sin_theta*Cos_theta/(5.0*K_alpha)*(1.0-10.0*pow(xi,3)+15.0*pow(xi,4)-6.0*pow(xi,5));
    }
    else{
        Fx[0] = -W*Cos_theta;
        Fy[0] = -W*Sin_theta;
        Tsat[0]=3.0*l*pow(W,2)*Sin_theta*Cos_theta/(5.0*K_alpha);
    }
}
    
else{
     lambda = sqrt( pow(sigma[0],2)+pow(K_alpha/K_sigma,2)*pow(1+sigma[0],2)*pow(tan(alpha[0]),2) );
     xi = 1-K_sigma/(3.0*W)*lambda;
    if (lambda == 0 && sigma == 0){ 
        Cos_theta = 1;
        Sin_theta = 0;
    }
    else{    
        Cos_theta = sigma[0]/lambda;
        Sin_theta = K_alpha*(1+sigma[0])*tan(alpha[0])/(K_sigma*lambda);
    }
    if (xi > 0){
        Fx[0] = -K_sigma*sigma[0]*pow(xi,2)-6.0*W*Cos_theta*(1.0/6.0-1.0/2.0*pow(xi,2)+1.0/3.0*pow(xi,3));
        Fy[0] = -K_alpha*(1+sigma[0])*pow(xi,2)*tan(alpha[0])-6*W*Sin_theta*(1.0/6.0-1.0/2.0*pow(xi,2)+1.0/3.0*pow(xi,3));
        Tsat[0] = l/2.0*K_alpha*(1+sigma[0])*tan(alpha[0])*pow(xi,2)*(1.0-4.0/3.0*xi)
        -3.0/2.0*l*W*Sin_theta*pow(xi,2)*pow(1-xi,2)
        +2.0/3.0*l*K_sigma*(1+sigma[0])*sigma[0]*tan(alpha[0])*pow(xi,3)
        +3.0*l*pow(W,2)*Sin_theta*Cos_theta/(5.0*K_alpha)*(1-10.0*pow(xi,3)+15.0*pow(xi,4)-6.0*pow(xi,5) );
    }
     else{
        Fx[0] = -W*Cos_theta;
        Fy[0] = -W*Sin_theta;
        Tsat[0] = 3.0*l*pow(W,2)*Sin_theta*Cos_theta/(5.0*K_alpha);
     }

}
/* %%%-SFUNWIZ_wrapper_Outputs_Changes_END --- EDIT HERE TO _BEGIN */
}
